<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R | API+.NET: F.A.Q. - R | Trade Execution Platform(tm)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">R | API+.NET<span id="projectnumber">&#160;Version 13.6.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('faq_std.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">F.A.Q. - R | Trade Execution Platform(tm) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="faq_std_toc"></a>
Table Of Contents</h1>
<ol>
<li>
<a class="el" href="faq_std.html#faq_rtrade_agreements">Agreements</a> </li>
<li>
<a class="el" href="faq_std.html#md_permissions">Market Data Permissions</a> </li>
<li>
<a class="el" href="faq_std.html#risk_limits">Risk Limits</a> </li>
<li>
<a class="el" href="faq_std.html#symbology">What Values Should I Use For Symbol/Ticker and Exchange?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_maintain_order_state">How do I maintain order state?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_changing_order_type">I submitted a stop market (or stop limit) order. Now I am receiving callbacks for this order number, but now the order type is different. What happened?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_many_send_order">Why are there so many ways to place or modify orders?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_send_order_error">I place an order and get the following error. What happened?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_unusual_order_behavior">Why are my orders behaving strangely in Rithmic Test?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_trade_routes">What are trade routes and how do I use them?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_cancel_after_30">What is this message about cancelling orders only after 30 seconds?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_multiple_rengines">Is it possible to instantiate multiple instances of REngine in a single process space?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_callback_once">Why does my market data callback only fire once?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_ticker_plant_order_plant_congruity_2">When I specify a limit price, the order is rejected due to the price being invalid or out of range. The market data stream indicates that the price should be okay. What happened?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_what_is_mit_lit">What are MIT and LIT orders?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_copy_account_info">Do I have to copy the AccountInfo instances that are given to me in RCallbacks::AccountList()?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_bool_flags">Why are there boolean flags associated with prices and sizes? What do they mean?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_instruction_enum">Why are there enums associated with values in certain classes?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_market_depth_updates">How do I maintain an order book? (Or, how do I use update types with AskInfo, BidInfo and EndQuoteInfo?)</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_what_is_dbo">What is DBO data and how might I use it?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_dbo_queue_position">How do I find queue position for my order using DBO data?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_continuous_contracts">What is a continuous contract?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_rtrade_binary_contracts">What is a binary contract?</a> </li>
<li>
<a class="el" href="faq_std.html#faq_std_quote_flags">What is the meaning of AskInfo::bPriceFlag, AskInfo::bSizeFlag, BidInfo::bPriceFlag and BidInfo::bSizeFlag?</a> </li>
</ol>
<hr  />
<h1><a class="anchor" id="faq_rtrade_agreements"></a>
Agreements</h1>
<p >There may be usage/license agreements (from exchanges, data providers, etc.) which must be accepted/signed by Rithmic users. These agreements are specific to each Rithmic system. If a mandatory agreement exists, but has not been accepted by a user, that user's login attempts to the trading platform will fail (conveyed via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a99baf44ef04aeb89b69b9af55da5a7bc" title="This method is invoked when the engine detects an alert condition.">RCallbacks::Alert()</a>), even with correct credentials.</p>
<p >However, one can discover which agreements exist, if they are mandatory, and if they have been accepted. First, one must log in successfully to the repository connect point using <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a3d742fed38a9524044a638c8ed74f4a9" title="Logs in to the repository sub-system.">REngine::loginRepository()</a>. To do so, one uses one's normal login credentials to the trading platform. However, the authentication for logging into the respository connect point does not rely on any acceptance of agreements. Alerts (<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a99baf44ef04aeb89b69b9af55da5a7bc" title="This method is invoked when the engine detects an alert condition.">RCallbacks::Alert()</a>) will convey the status of the login attempt to the repository connect point.</p>
<p >After logging in to the repository connect point, one can request agreements from the repository sub-system using <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#af8f8cd75a3907a6f42ae74424d2daf34" title="Requests the list of agreements for the Rithmic system connected to via REngine::loginRepository().">REngine::listAgreements()</a>. One can request accepted or unaccepted agreements. The results are returned via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a4a64f798e294c55cd9f14b5330bcfcd2" title="This method is invoked when the engine receives a list of agreements from the infrastructure.">RCallbacks::AgreementList()</a>.</p>
<p >The <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AgreementInfo.html" title="This class represents an agreement.">AgreementInfo</a> class has a flag indicating whether the agreement is mandatory or not. If there are mandatory agreements which have not been accepted, one must log in to that system (e.g. Rithmic Test) using R | Trader or R | Trader Pro, and accept those agreements. After doing so, the user will be able to log in to the trading platform normally. Because these agreements are specific to each Rithmic system, it is possible that one must accept agreements for multiple systems as they are accessed (i.e. Rithmic Test, Rithmic Paper Trading, etc.)</p>
<p >It is not possible to accept agreements or view their contents using R | API. <br  />
 For these tasks one must use R | Trader or R | Trader Pro.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a3d742fed38a9524044a638c8ed74f4a9" title="Logs in to the repository sub-system.">REngine::loginRepository</a> </dd>
<dd>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a21f15f286d58eb57693adaefed27092b" title="Logs out of the repository sub-system.">REngine::logoutRepository</a> </dd>
<dd>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#af8f8cd75a3907a6f42ae74424d2daf34" title="Requests the list of agreements for the Rithmic system connected to via REngine::loginRepository().">REngine::listAgreements</a> </dd>
<dd>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AgreementListInfo.html" title="An instance of this class represents a collection of agreements.">AgreementListInfo</a> </dd>
<dd>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AgreementInfo.html" title="This class represents an agreement.">AgreementInfo</a></dd></dl>
<hr  />
<h1><a class="anchor" id="md_permissions"></a>
Market Data Permissions</h1>
<p >If you find that you cannot subscribe for market data, your User ID may not have permissions on those instruments. Contact the organization that provided you with your User ID and ask them for market data entitlements to that instrument.</p>
<hr  />
<h1><a class="anchor" id="risk_limits"></a>
Risk Limits</h1>
<p >If you find that when you place an order and get an error message about risk limits not being set, the Account under which you are placing the order may not have risk settings configured for that instrument. Contact the organization that provided you with your Account and ask them to set risk limits for that instrument.</p>
<p >It is also possible that the risk management algorithm used for your Account does not apply to the instrument you are trying to trade. As above, contact the orgranization which provided the Account to get the appropriate risk configuration set up.</p>
<hr  />
<h1><a class="anchor" id="symbology"></a>
What Values Should I Use For Symbol/Ticker and Exchange?</h1>
<p >The R | API typically uses the same symbology as the exchange's data feed. Exchange names tend to be all upper case letters. A quick way to get positive confirmation is to call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ab5238f8d91a66d4564ab0f2c868f4814" title="Requests reference data for the specified instrument.">REngine::getRefData()</a> for the instrument. If you get back data, the values were good. If you get back an error code of 7, or 'no data', the instrument may not exist. (The infrastructure has no data on the instrument specified.) This test should work whether or not your User ID has market data permissions on that instrument.</p>
<p >If you have R | Trader, you can use the Search/Add Symbol window to find the instrument.</p>
<hr  />
<h1><a class="anchor" id="faq_std_maintain_order_state"></a>
How do I maintain order state?</h1>
<p >One maintains order state by applying updates to the set of existing or known orders.</p>
<p >To get updates for orders placed under an account, one calls <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#aca9fa2f9cdbf1fbeba9cc9e8cb2a1401" title="Subscribes to order updates for the specified Rithmic account.">REngine::subscribeOrder()</a>. There are a number of callbacks that will be invoked as order updates are published by the infrastructure. These callbacks will use the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReport.html" title="This class represents an order event.">OrderReport</a> and <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html" title="This class represents a summary of an order.">LineInfo</a> classes to convey order information. In general, the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReport.html" title="This class represents an order event.">OrderReport</a> callbacks indicate some event has occurred.</p>
<p >To get a snapshot of orders placed under an account, one should call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a0d4815c2003e67dbc7b360466cf3748f" title="Requests snapshots of all orders from the current trading session placed under a specified account.">REngine::replayAllOrders()</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ad80eddd1ad0b62029bdb236a6b86da2a" title="Sends a request to retrieve all open orders placed under a specified account.">REngine::replayOpenOrders()</a>, depending on whether one wants all orders from the current trading session, or just the open orders at that moment. The orders will be returned via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a91325b99269cfca9e6d5e9842f135840" title="This method is invoked when the engine receives a response from the infrastructure for a request to R...">RCallbacks::OrderReplay()</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#aad60a5d943a762ad4c511732395718da" title="This method is invoked when the engine receives a response from the infrastructure for a request to R...">RCallbacks::OpenOrderReplay()</a> in an <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReplayInfo.html" title="An instance of this class represents a collection of orders.">OrderReplayInfo</a> instance which will contain an array of <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html" title="This class represents a summary of an order.">LineInfo</a> objects. These <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html" title="This class represents a summary of an order.">LineInfo</a> objects represent the order snapshots.</p>
<p >In order not to miss any updates, it is important to call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#aca9fa2f9cdbf1fbeba9cc9e8cb2a1401" title="Subscribes to order updates for the specified Rithmic account.">REngine::subscribeOrder()</a> prior to calling <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a0d4815c2003e67dbc7b360466cf3748f" title="Requests snapshots of all orders from the current trading session placed under a specified account.">REngine::replayAllOrders()</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ad80eddd1ad0b62029bdb236a6b86da2a" title="Sends a request to retrieve all open orders placed under a specified account.">REngine::replayOpenOrders()</a>. If an update is published after the replay orders request is handled, but before the subscribe call is made, that update will be lost.</p>
<p >If one is considering migrating to R | Diamond Cutter, it may be prudent to rely only on <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReport.html" title="This class represents an order event.">OrderReport</a> callbacks to maintain state, as the R | Diamond Cutter system does not publish as much convenience information and updates in the form of <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html" title="This class represents a summary of an order.">LineInfo</a> instances via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#abc98318b7d4d75d2ff40c9bd45595643" title="This method is invoked when the engine receives a LineInfo update from the infrastructure about an or...">RCallbacks::LineUpdate</a>.</p>
<hr  />
<h1><a class="anchor" id="faq_std_changing_order_type"></a>
I submitted a stop market (or stop limit) order.  Now I am receiving  callbacks for this order number, but now the order type is different.  What happened?</h1>
<p >R | API generally forwards order information as it is provided by the exchanges. It is possible that the exchange will change the order type of an order during its life cycle.</p>
<p >For example, when a CME stop market order is triggered, it becomes a limit order. The reason this happens is because the CME does not support a 'true' market order, but instead what they call a 'market order (with protection)'. When a stop market order is triggered, the exchange converts the order type to a limit order.</p>
<hr  />
<h1><a class="anchor" id="faq_std_many_send_order"></a>
Why are there so many ways to place or modify orders?</h1>
<p >There are four convenience routines to provide a more simple interface for placing common types of orders : </p><ul>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ae7abd7560df9ad2b49f6f21cf44b7567" title="Sends a request to place a limit order.">REngine::sendOrder(LimitOrderParams)</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a2fcbeeb130d9193ed978e2f9666684ed" title="Sends a request to place a market order.">REngine::sendOrder(MarketOrderParams)</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a9bf21ec887072e045be17f4ca860b75d" title="Sends a request to place a stop limit order.">REngine::sendOrder(StopLimitOrderParams)</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a90c1efff0c9b2bb2151e956ee3861b4d" title="Sends a request to place a stop market order.">REngine::sendOrder(StopMarketOrderParams)</a> </li>
</ul>
<p >These methods are provided for users who do not need the complete set of parameters associated with a placing an order. The more generalized method for placing an order is <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#aa9682281685f9bbe422e573d995fcd93" title="Sends a request to place a list of orders.">REngine::sendOrderList()</a>. This method allows users to place multiple orders simultaneously, with more parameters for each order. It is also more complex. It is called internally by the simpler sendOrder() methods.</p>
<p >The same idea applies to <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a3297ce335026433044b0304667f9b036" title="Sends a request to modify an existing order.">REngine::modifyOrder()</a>, except that you can't modify a list of orders with one call.</p>
<hr  />
<h1><a class="anchor" id="faq_std_send_order_error"></a>
I place an order and get the following error. What happened?</h1>
<p >An error of 11 (API_NO_HANDLE or 'no handle') when placing an order may mean that you are not currently logged in to the trading system (there is no handle representing the trading system connection). When you log in, do you specify a value for LoginParams::sTsCnnctPt? (See SampleOrder.cpp for an example.) Also, do you get an Alert callback indicating that the login is complete (AlertInfo::iAlertType equals ALERT_LOGIN_COMPLETE)? It is also possible that the login handshake is not yet done or the connection is in recovery.</p>
<p >An error of 23 (API_MINOR_ERROR or 'minor error') means that the R | API does not have instrument-specific data that is used internally. This internally used data is typically retrieved automatically when subscribing to the market data of a particular instrument. When placing orders in C++, this data is not retrieved automatically, as it requires a round trip to the infrastructure before actually sending the order requiest. However, you can get the reference data explicitly by doing the following : </p><pre class="fragment">Call REngine::getPriceIncrInfo(), which will cause RCallbacks::PriceIncrUpdate() to fire.
Check the value of PriceIncrInfo::iRpCode in the callback. If the value of iRpCode is API_OK (0), then you have this reference data necessary for placing orders.
</pre><p> The reason this extra step is not done automatically is to allow latency sensitive users to retrieve this data manually before any orders need to be placed.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_unusual_order_behavior"></a>
Why are my orders behaving strangely in Rithmic Test?</h1>
<p >Rithmic Test connects to exchanges' test matching engines and market data distribution systems. The market represented by this test system is generally different from what one might see in a production environment, as it represents the market activity of other testers. The test environment might have very little order flow, and consequently, very little market data. The market data that is published may be drastically different than live market data. Furthermore, sometimes the exchange's test matching engine and test market data can be out-of-sync.</p>
<p >An exchange may have matching algorithms and features which, combined with a sparse market as one might find in the test system, yield unexpected order behavior. Examples of such features are market orders with protection (market orders cannot be filled outside of a particular price range) and price banding (orders cannot be placed outside of a particular price range).</p>
<p >For example, a market order (with protection) might be converted to a limit order if there are no matching orders within the allowable price range. However, automatically generated limit price of this market order might fall outside of the trading session's price band. In this case, it may appear that the market order should have been filled, but is instead rejected. Sometimes the exchange's error text (found in <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderRejectReport.html" title="The OrderRejectReport represents the rejection of a request to place an order and is passed in RCallb...">OrderRejectReport</a>) can be used to figure out what happened.</p>
<hr  />
<h1><a class="anchor" id="faq_std_trade_routes"></a>
What are trade routes and how do I use them?</h1>
<p >Some accounts have access to multiple gateways that support orders on the same instrument. A trade route specifies such a gateway. As such, a number of order requests require the trade route to be specified as a parameter. Even when an account/instrument has only a single trade route, the trade route must still be specified.</p>
<p >Available trade routes can be retrieved from the infrastructure and monitored. To do so, the engine must be connected and logged in to the trading system connect point (<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a5451b983c9ec27d76e0ca4b3ac49e211" title="Initiates logging into the system.">REngine::login()</a>). Some order snapshots and updates will convey the trade route associated with the order.</p>
<p >Retrieving and maintaining state for trade routes follows the Snapshot-Update Pattern (<a class="el" href="programmers_guide.html#pg_updates_and_snapshots">Establishing And Maintaining State With The Snapshot-Update Pattern</a>), with <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#af1dab8735e1c6dbb41817157d3e05303" title="Retrieves the list of available trade routes (snapshot).">REngine::listTradeRoutes()</a> providing the snapshot and <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ab7e79b4553b07d2e2bfddc9147e0f95d" title="Subscribes to trade route updates for the specified Rithmic FCM/IB.">REngine::subscribeTradeRoute()</a> providing updates.</p>
<p >For more information see the following :</p>
<ul>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#af1dab8735e1c6dbb41817157d3e05303" title="Retrieves the list of available trade routes (snapshot).">REngine::listTradeRoutes()</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ab7e79b4553b07d2e2bfddc9147e0f95d" title="Subscribes to trade route updates for the specified Rithmic FCM/IB.">REngine::subscribeTradeRoute()</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a2d065b074ed463b487bbd853c37d765d" title="Unsubscribes from trade route updates for the specified Rithmic FCM/IB.">REngine::unsubscribeTradeRoute()</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1TradeRouteInfo.html" title="Trade route for an fcm/ib to an exchange.">TradeRouteInfo</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderParams.html#a56f971af39c15d902c8e6aaae594a9b5" title="Specifies the trade route.">OrderParams::TradeRoute</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LimitOrderParams.html#a56f971af39c15d902c8e6aaae594a9b5" title="Specifies the trade route.">LimitOrderParams::TradeRoute</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1MarketOrderParams.html#a56f971af39c15d902c8e6aaae594a9b5" title="Specifies the trade route.">MarketOrderParams::TradeRoute</a> </li>
<li>
<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html#a56f971af39c15d902c8e6aaae594a9b5" title="Trade route specified when placing this order.">LineInfo::TradeRoute</a> </li>
</ul>
<hr  />
<h1><a class="anchor" id="faq_std_cancel_after_30"></a>
What is this message about cancelling orders only after 30 seconds?</h1>
<p >The reason for the "Send cancels only after 30 secs. More cancels within
this period will lead to logoff/disable of this user." message is because you probably sent a cancel request for an order that was already complete and so the cancellation request failed.</p>
<p >The Rithmic platform expects clients to refrain from requesting order cancellations if the order is already complete, and also expects users to not send more than once cancel request per order. If a cancel request is rejected, generally it is usually not a good idea to automatically send a subsequent cancel.</p>
<p >Usually this scenario indicates a race condition where the order was complete but the client app didn't know it yet. Other times it indicates something awry with the client order state management. However, sometimes this behavior indicates a program that has gone out of control. <br  />
</p>
<p >We have automated sentinels which will logoff/disable such programs. Currently the threshold for such sentinels is if 10 cancels received in a 30 second period for an order where a cancel has been rejected. Sending less than 10 cancels in a 30 second period will not trigger the sentinels, and waiting an additional 30 seconds will also not trigger these sentinels.</p>
<hr  />
<h1><a class="anchor" id="faq_std_multiple_rengines"></a>
Is it possible to instantiate multiple instances of REngine in a single process space?</h1>
<p >Using multiple instances of the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html" title="This class initiates all functionality within the R | API.">REngine</a> within a single process space is not intended or tested. The <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html" title="This class initiates all functionality within the R | API.">REngine</a> can be regarded as something of a singleton, even though the singleton pattern is not enforced by the interface. Having said that, there have been reports from the field where an application does instantiate multiple REngines successfully.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_callback_once"></a>
Why does my market data callback only fire once?</h1>
<p >When subscribing to market data, the first callback invocation is usually the image callback. The image callback represents the most recent value, or snapshot, of the data. As new/updated data becomes available and is published, the callback will be invoked again. (If there are no updates, the callback will not be invoked.)</p>
<p >For some subscriptions, the callback may not fire so frequently because the updates are infrequent. Subscribing to market mode updates is an example. Sometimes, callbacks will not fire because there are no updates, even though one normally expects many updates. An example might be subscriptions to trades on highly traded instruments, but in the Rithmic Test environment. The lack of updates can occur because the market data in that environment is driven from the exchanges' test environments and can be very, very sparse.</p>
<hr  />
<h1><a class="anchor" id="faq_std_ticker_plant_order_plant_congruity"></a>
In the test environment, I place an order but I don't see the order appear in the market data stream.  What happened?</h1>
<p >This scenario shouldn't happen in a production environment. However, in test environments, the matching engine producing the market data feed and the order matching engine handling orders may not be the same. It may depend on which connect points you used to log in, or how the exchange is configuring their test environment at the time.</p>
<hr  />
<h1><a class="anchor" id="faq_std_ticker_plant_order_plant_congruity_2"></a>
When I specify a limit price, the order is rejected due to the price being invalid or out of range.  The market data stream indicates that the price should be okay.  What happened?</h1>
<p >As above, this can happen if order matching engine is not producing the market data stream.</p>
<hr  />
<h1><a class="anchor" id="faq_std_what_is_mit_lit"></a>
What are MIT and LIT orders?</h1>
<p >Market-If-Touched and Limit-If-Touched orders are market or limit orders which are held within the infrastructure, and then placed by the infrastructure if and when a pre-defined market data condition is met (or "touched"). One can specify the instrument, the price type (trade, best bid, or best ask), and an operator. The following parameters are used : </p><pre class="fragment">     &lt;ul&gt;
     &lt;li&gt;
     OrderParams::sTriggerTicker - the instrument name
     &lt;/li&gt;
     &lt;li&gt;
     OrderParams::sTriggerExchange - the instrument's exchange
     &lt;/li&gt;
     &lt;li&gt;
     OrderParams::dTriggerPrice - the price to evaluate
     &lt;/li&gt;
     &lt;li&gt;
     OrderParams::iTriggerCmpOperator - the comparison operator to use
     &lt;/li&gt;
     &lt;li&gt;
     OrderParams::iTriggerPriceId - the type of price to use
     &lt;/li&gt;
     &lt;/ul&gt;
</pre><p> For example, one can place a limit order when CME's ESM0 trades at a price greater than 1200. The following values would be used : </p><ul>
<li>
OrderParams::sOrderType - RApi::sORDER_TYPE_LMT_IF_TOUCHED  </li>
<li>
OrderParams::sTriggerTicker - ESH0  </li>
<li>
OrderParams::sTriggerExchange - CME  </li>
<li>
OrderParams::dTriggerPrice - 1200.00  </li>
<li>
OrderParams::iTriggerCmpOperator - RApi::OP_GREATER_THAN  </li>
<li>
OrderParams::iTriggerPriceId - RApi::TRADE_PRICE  </li>
</ul>
<p >The MIT/LIT orders can only be placed using <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#aa9682281685f9bbe422e573d995fcd93" title="Sends a request to place a list of orders.">REngine::sendOrderList()</a>. It is possible that the order is sent immediately if the condition is currently true. Finally, the instrument of the underlying market or limit order does not have to be the same instrument used in the trigger condition. </p><pre class="fragment"> &lt;hr&gt;
</pre> <h1><a class="anchor" id="faq_copy_account_info"></a>
Do I have to copy the AccountInfo instances that are given to me in RCallbacks::AccountList()?</h1>
<p >Yes, you should retain your own copies of the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AccountInfo.html" title="This class represents an account.">AccountInfo</a> instances. When placing orders, or making other method calls which require a pointer to an <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AccountInfo.html" title="This class represents an account.">AccountInfo</a> instance, you can leave the AccountInfo::pRmsInfo value nulled.</p>
<hr  />
<h1><a class="anchor" id="faq_bool_flags"></a>
Why are there boolean flags associated with prices and sizes?  What do they mean?</h1>
<p >It is sometimes possible that the value of something becomes undefined. When an undefined value is passed to a callback, the value of the flag indicates whether the value of the typed data (usually a double for prices and an integer for sizes) is undefined or not. Therefore, when using callbacks where such flags are available, the value of the flag must be checked prior to using the value of the associated data.</p>
<hr  />
<h1><a class="anchor" id="faq_instruction_enum"></a>
Why are there enums associated with values in certain classes?</h1>
<p >In R | API, there are member variables which change over time, not just in value, but between states of being well-defined or not defined.</p>
<p >One example is the average open fill price for a position. Until a position is opened, there is no average open fill price. It does not exist. While the position is held, however, there is a well-defined average open fill price. Finally, when the position is closed, the average open fill price ceases to exist.</p>
<p >The enums sent for the above example would be ValueState.Clear prior to when the position is opened, ValueState.Use while there is a position and average open fill price, and then finally ValueState.Clear when the position is closed.</p>
<p >Another example is margin balance for an account using the minimum account balance algorithm. The risk manager does not calculate the margin balance for such an account as it is not used to allow or deny order operations. So any pnl updates would indicate ValueState.Clear for the margin balance value. <br  />
 This instruction indicates that the margin balance does not exist, or does not apply.</p>
<p >Finally, there is the instruction to ignore a value. One of the optimizations used by the infrastructure is to minimize the size and frequency of messages. The impact of these optimizations on R | API interface is that sometimes updates can be 'sparse'. R | API classes are designed to group related data and bundle them up into classes. However, it is possible that only a subset of member variables within a class instance has changed. In this case, the infrastructure may not transmit a complete set of data corresponding to the class. Instead, it will send only the data which has changed. The member variables which are NOT being updated will be marked with ValueState.Ignore. This indicates that any previously transmitted value for that variable should not be updated or discarded.</p>
<p >An example of this might be when the open pnl (which depends on current market conditions) updates, while the average open fill price (which depends on fill events) does not. In this case, the infrastructure may send an update which only includes the open pnl value.</p>
<p >This convention is not designed to replace the boolean flag convention used elsewhere in R | API. However, it is used where the boolean flag convention is not sufficient to convey the state of affairs accurately.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcom_1_1omnesys_1_1rapi_1_1Ignorable.html" title="Represents an object whose underlying type is a value type that has an associated state indicating wh...">Ignorable</a> </dd>
<dd>
ValueState.Ignore </dd>
<dd>
ValueState.Clear </dd>
<dd>
ValueState.Use</dd></dl>
<hr  />
<h1><a class="anchor" id="faq_std_market_depth_updates"></a>
How do I maintain an order book?  (Or, how do I use update types with AskInfo, BidInfo and EndQuoteInfo?)</h1>
<p >To get a snapshot of depth of market data for an order book, one can call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a37b8b66981e86d344b9313e13fb721b4" title="Requests an order book image for the specified instrument.">REngine::rebuildBook()</a>, which causes <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a833492e98da03446353d6c8fbecb833e" title="This method is invoked when the engine receives a limit order book.">RCallbacks::LimitOrderBook()</a> to fire. <br  />
 Although it may seem easy to continually call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a37b8b66981e86d344b9313e13fb721b4" title="Requests an order book image for the specified instrument.">REngine::rebuildBook()</a> whenever one wishes to see the current order book, it can be quite resource intensive and slow compared to getting continual updates using subscriptions.</p>
<p >To get continual updates to depth of market data, one should call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a08648179eaa4e6e7c679e0ece6c2ccf6" title="Subscribes to market data for the specified instrument.">REngine::subscribe()</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a19f5e7b01cdf2351fb0b557a562f0331" title="Subscribes by underlying instrument.">REngine::subscribeByUnderlying()</a>, and specify the <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#af02522f98457d628b8f7c6b6d1d9234cac9a28e7f0dbc3ed20a161351c4f29a7b" title="This subscription flag represents quote, or depth of market, messages.">SubscriptionFlags.Quotes</a> flag. The first callback to fire is <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a833492e98da03446353d6c8fbecb833e" title="This method is invoked when the engine receives a limit order book.">RCallbacks::LimitOrderBook()</a>, which provides a snapshot of the entire order book. This order book snapshot should be saved by the application. Subsequent updates will arrive via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#ac5b030ef20c07acc3ec0f3d29f86467d" title="This method is invoked when the engine receives an ask quote from the market data feed.">RCallbacks::AskQuote()</a>, <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#ac5200164470a950ebf8f7c8dd589d1a8" title="This method is invoked when the engine receives a bid quote from the ticker plant.">RCallbacks::BidQuote()</a>, <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a176a71aa8a109707becf8f10e8a83bed" title="This method is invoked to indicate the end of a group of quote updates.">RCallbacks::EndQuote()</a> and/or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a833492e98da03446353d6c8fbecb833e" title="This method is invoked when the engine receives a limit order book.">RCallbacks::LimitOrderBook()</a>. These updates should be applied to the previously saved order book.</p>
<p >Sometimes atomic updates to an order book span multiple price levels, and/or both sides of the order book. In the R | API, there is one callback per side and price level, so these updates can span multiple callback invocations. For example, if an update to the order book spans two bid price levels, the R | API will invoke <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#ac5200164470a950ebf8f7c8dd589d1a8" title="This method is invoked when the engine receives a bid quote from the ticker plant.">RCallbacks::BidQuote()</a> twice. However, the order book should only be evaluated after the second update.</p>
<p >The update type provides the additional information to determine when the order book can be evaluated. If the update is a solitary update, the type will be <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2a26c04769d2607a2234d4329b7630ed35" title="Indicates the update is a solitary update.">UpdateType.Solo</a> and the order book can be evaluated immediately. If the update is part of a set of updates, the set will begin with an update type of <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2a1a06729125544cab7cee73195fc044f0" title="Indicates the update is the first update of a group of updates.">UpdateType.Begin</a> and end with an update type of <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2a87557f11575c0ad78e4e28abedc13b6e" title="Indicates the update is part of a group of updates, and is the last update.">UpdateType.End</a>. There may be additional <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2ab1ca34f82e83c52b010f86955f264e05" title="Indicates the update is part of a group of updates, and is neither the first update or the last updat...">UpdateType.Middle</a> updates in between. Although there is price level information with types <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2a1a06729125544cab7cee73195fc044f0" title="Indicates the update is the first update of a group of updates.">UpdateType.Begin</a> and <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2ab1ca34f82e83c52b010f86955f264e05" title="Indicates the update is part of a group of updates, and is neither the first update or the last updat...">UpdateType.Middle</a>, it is possible for <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2a87557f11575c0ad78e4e28abedc13b6e" title="Indicates the update is part of a group of updates, and is the last update.">UpdateType.End</a> to have no price information. When this occurs the update type will be conveyed via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a176a71aa8a109707becf8f10e8a83bed" title="This method is invoked to indicate the end of a group of quote updates.">RCallbacks::EndQuote()</a>.</p>
<p >If a user subscribes to <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#af02522f98457d628b8f7c6b6d1d9234ca68ef004de6166492c1d668eb8efe09bd" title="This subscription flag represents best bid and best ask quote messages.">SubscriptionFlags.Best</a>, the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1BidInfo.html" title="This class represents a bid quote.">BidInfo</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1AskInfo.html" title="This class represents an ask quote.">AskInfo</a> objects passed via <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#affce9ba17f435ad284dd56bc9890e599" title="This method is invoked when the engine receives a best bid quote from the ticker plant.">RCallbacks::BestBidQuote()</a>, <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a13546aeb65813d5059d9e6b1ab33208f" title="This method is invoked when the engine receives one message with both a best bid quote and a best ask...">RCallbacks::BestBidAskQuote()</a>, and/or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RCallbacks.html#a5f6022a443df5f3fa2e0efaa6b46a45c" title="This method is invoked when the engine receives a best ask quote from the ticker plant.">RCallbacks::BestAskQuote()</a> will have their update types set to <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2aec0fc0100c4fc1ce4eea230c3dc10360" title="Indicates an undefined value and does not apply.">UpdateType.Undefined</a>.</p>
<p >Finally, <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#a0957e0df001dd796895b75f947daddb2adc30bc0c7914db5918da4263fce93ad2" title="Reserved for internal use.">UpdateType.Clear</a> is only used internally.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_what_is_dbo"></a>
What is DBO data and how might I use it?</h1>
<p >Some exchanges provide market depth data in the form of individual orders comprising the order book. Rithmic calls this order-centric approach to disseminating market depth data "depth-by-order", or DBO (see <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1DboInfo.html" title="This class represents depth-by-order (DBO) market data.">DboInfo</a>). <br  />
 Similar data is sometimes called market-by-order (mbo) data or order-by-order data. Each order might have a side, price and quantity. It might also have an exchange order id, as well as some indication of where in the matching queue this order rests. This indication of queue position is sometimes called order priority or time-price-priority. Rithmic calls this priority (see <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1DboInfo.html#a74ea5a3b0bd2bed7c593b434c632d81f" title="Priority of this order in the exchange&#39;s matching engine queue.">DboInfo::Priority</a>).</p>
<p >Dbo data is in contrast to price-centric market depth data, which associates an available (visible) quantity with a given price. This price-centric approach is sometimes referred to as market-by-price data.</p>
<p >Depth-by-order data is supported by R | API+ or above.</p>
<p >Market-by-price data is supported by all versions of R | API.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_dbo_queue_position"></a>
How do I find queue position for my order using DBO data?</h1>
<p >Depth-by-order data is supported by R | API+ or above. The following example applies to Globex/CME data at the time of writing.</p>
<p >Finding an order's queue position requires the exchange order id as well as all the orders (with their respective order priorities) for that instrument at that price and on that side of the order book.</p>
<p >The exchange assigns a unique exchange order id (which is not the same as the Rithmic order number) when it creates an order. This value is normally in <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html#a2f0e682573a2dc8c6afeb065513b3b37" title="When available, contains the order id assigned by the exchange for this order.">LineInfo::ExchOrdId</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReport.html#a2f0e682573a2dc8c6afeb065513b3b37" title="This is the order id assigned to the order by the exchange.">OrderReport::ExchOrdId</a>. You must be subscribing to order updates for the account on which the order was placed (see <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#aca9fa2f9cdbf1fbeba9cc9e8cb2a1401" title="Subscribes to order updates for the specified Rithmic account.">REngine::subscribeOrder()</a>) to get the <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1LineInfo.html" title="This class represents a summary of an order.">LineInfo</a> or <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1OrderReport.html" title="This class represents an order event.">OrderReport</a> updates on your order.</p>
<p >Next, you need the collection of all resting orders for that instrument at that price and side. Each order in the collection should have an exchange order id (<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1DboInfo.html#a2f0e682573a2dc8c6afeb065513b3b37" title="Exchange order id of this order.">DboInfo::ExchOrdId</a>), including your order of interest. Each order in the collection should also have a matching engine priority (<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1DboInfo.html#a74ea5a3b0bd2bed7c593b434c632d81f" title="Priority of this order in the exchange&#39;s matching engine queue.">DboInfo::Priority</a>). This field is a string in the Rithmic interface, although, for Globex, it translates to a numeric value (64-bit unsigned long). The lower the priority, the closer that order is to the front of the queue. By examining all the order priorities and order quantities in the collection, one can determine how many orders and how much quantity is ahead in the exchange queue.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_continuous_contracts"></a>
What is a continuous contract?</h1>
<p >Futures contracts generally have some periodic expiration (weekly, monthly, or quarterly, for example). Related to the expiration is when these contracts are available to trade. Contract specifications as published by exchanges normally detail when an expiry of a particular future becomes available to trade, and when it can no longer be traded.</p>
<p >When examining historical data (i.e. candlestick data) for a particular future, some find it convenient to examine data across various expiration dates, enabling time horizons which extend beyond the tradeable time periods of any individual futures contract.</p>
<p >In Rithmic, the 'continuous contract' refers to an alias ticker symbol for a futures contract, used to indicate the highest volume futures contract within a product group. This often is the same as the front month contract, the futures contract which has the nearest expiry date.</p>
<p >Normally one can access a continuous contract's data by specifying the product code instead of the futures ticker symbol. This alias can be used to retrieve reference data, subscribe for most market data, and subscribe for or retrieve candlestick data. However, one cannot subscribe to market depth data using continuous contracts, and one cannot place orders using continuous contracts.</p>
<p >One can discover the actual future of the continuous contract using R | API+. To do this, one can call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#ab5238f8d91a66d4564ab0f2c868f4814" title="Requests reference data for the specified instrument.">REngine::getRefData()</a> for the continuous contract, or call <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a08648179eaa4e6e7c679e0ece6c2ccf6" title="Subscribes to market data for the specified instrument.">REngine::subscribe()</a> with the reference data subscription flag enabled. The actual contract will be specified in the returned RefDataInfo::TradingTicker and <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RefDataInfo.html#aa51839af63080e805599ccf7cc0f22e3" title="Trading exchange of the instrument.">RefDataInfo::TradingExchange</a>.</p>
<hr  />
<h1><a class="anchor" id="faq_rtrade_binary_contracts"></a>
What is a binary contract?</h1>
<p >Binary contracts are sometimes called "binary options" or "bull spreads". The binary contract type of "Fixed" is a binary option and binary contract types of "Varible", "Narrow Spread", and "Wide Spread" are bull spreads.</p>
<p >These types may change, as the string values are provided by the exchange. The definition of these contract types are conveyed with <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1RefDataInfo.html" title="This class represents reference data for an instrument.">RefDataInfo</a> instances and can be retrieved from a database (REngine::getBinaryContractList()) or via subscription (<a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a19f5e7b01cdf2351fb0b557a562f0331" title="Subscribes by underlying instrument.">REngine::subscribeByUnderlying()</a>).</p>
<p >Fixed binary contracts (binary options) have a single price (RefDataInfo::dStrikePrice) with an operator (RefDataInfo::sStrikeOperator) which indicates the payout threshold of the option.</p>
<p >Variable/spread binary contracts (bull spreads) have a price range (RefDataInfo::dFloorPrice and RefDataInfo::dCapPrice) which determines the payout range. In this case the RefDataInfo::dStrikePrice indicates the midpoint in the payout price range.</p>
<p >Some binary contracts are intraday, existing only for a time period of an hour or two during a trading session. To subscribe to these instrument definitions, one should use <a class="el" href="classcom_1_1omnesys_1_1rapi_1_1REngine.html#a19f5e7b01cdf2351fb0b557a562f0331" title="Subscribes by underlying instrument.">REngine::subscribeByUnderlying()</a> and specify <a class="el" href="namespacecom_1_1omnesys_1_1rapi.html#af02522f98457d628b8f7c6b6d1d9234cac6241fe35a76bb34beef98f444fe749d" title="This subscription flag represents reference data (security definition) messages.">SubscriptionFlags::RefData</a> as a subscription flag.</p>
<p >For additional information, one can reference the documentation on NADEX, or contact Rithmic.</p>
<hr  />
<h1><a class="anchor" id="faq_std_quote_flags"></a>
What is the meaning of AskInfo::bPriceFlag, AskInfo::bSizeFlag, BidInfo::bPriceFlag and BidInfo::bSizeFlag?</h1>
<pre class="fragment"> &lt;table&gt;
      &lt;tr&gt;
           &lt;td&gt;
           &lt;b&gt;Callback&lt;/b&gt;
           &lt;/td&gt;
           &lt;td&gt;
           &lt;b&gt;Condition&lt;/b&gt;
           &lt;/td&gt;
           &lt;td&gt;
           &lt;b&gt;Meaning&lt;/b&gt;
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestAskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == true
           AskInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This AskInfo represents the current best ask price and size.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestAskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == true
           AskInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestAskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == false
           AskInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur, but can be interpreted as
           there is no best ask price.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestAskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == false
           AskInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           There is no best ask price.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestBidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == true
           BidInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This BidInfo represents the current best bid price and size.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestBidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == true
           BidInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestBidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == false
           BidInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur, but can be interpreted as
           there is no best bid price.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BestBidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == false
           BidInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           There is no best bid price.
           &lt;/td&gt;
      &lt;/tr&gt;






      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::AskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == true
           AskInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This AskInfo represents a current ask price and size.
           &lt;p&gt;
           If a price level is no longer a part of the 'known' order book, 
           the size will have a value of zero.  Some exchanges make 
           available only a certain number of price levels.  If a price 
           level moves beyond the depth provided by the exchange, the size
           will be zero, indicating that this price is no longer part of
           the 'known' order book.  Note that in this case, one cannot 
           categorically assume that the available quantity at this price 
           is zero.
           &lt;/p&gt;
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::AskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == true
           AskInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur, but can be interpreted as
           a price for which the available size is unknown.
           A size which is unknown is not necessarily zero.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::AskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == false
           AskInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::AskQuote()
           &lt;/td&gt;
           &lt;td&gt;
           AskInfo::bPriceFlag == false
           AskInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == true
           BidInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This BidInfo represents a current bid price and size.
           &lt;p&gt;
           If a price level is no longer a part of the 'known' order book, 
           the size will have a value of zero.  Some exchanges make 
           available only a certain number of price levels.  If a price 
           level moves beyond the depth provided by the exchange, the size
           will be zero, indicating that this price is no longer part of
           the 'known' order book.  Note that in this case, one cannot 
           categorically assume that the available quantity at this price 
           is zero.
           &lt;/p&gt;
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == true
           BidInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This condition should not occur, but can be interpreted as
           a price for which the available size is unknown.
           A size which is unknown is not necessarily zero.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == false
           BidInfo::bSizeFlag == true
           &lt;/td&gt;
           &lt;td&gt;
           This should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;

      &lt;tr&gt;
           &lt;td&gt;
           RCallbacks::BidQuote()
           &lt;/td&gt;
           &lt;td&gt;
           BidInfo::bPriceFlag == false
           BidInfo::bSizeFlag == false
           &lt;/td&gt;
           &lt;td&gt;
           This should not occur.
           &lt;/td&gt;
      &lt;/tr&gt;
 &lt;/table&gt;
</pre> <hr  />
<p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="faq_root.html">F.A.Q.</a></li>
    <li class="footer">Generated on Mon Oct 13 2025 13:29:09 for R | API+.NET by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
